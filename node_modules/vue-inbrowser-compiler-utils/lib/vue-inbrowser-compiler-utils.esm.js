import { isVue3, parseComponent, compileScript, compileTemplate } from 'vue-inbrowser-compiler-demi';
export { Vue2, compileScript, compileTemplate, createApp, h, isVue3, parseComponent } from 'vue-inbrowser-compiler-demi';
export { addScopedStyle, cleanName, getDefaultExample, transformOneImport } from 'vue-inbrowser-compiler-independent-utils';
import camelCase from 'camelcase';

/**
 * Groups attributes passed to a React pragma to the VueJS fashion
 * @param h the VueJS createElement function passed in render functions
 * @returns pragma usable in buble rendered JSX for VueJS
 */
function adaptCreateElement(h) {
    return (comp, attr, ...children) => {
        if (attr === undefined) {
            return h(comp);
        }
        else if (!children.length) {
            return h(comp, groupAttr(attr));
        }
        return h(comp, groupAttr(attr), children);
    };
}
const rootAttributes = [
    'staticClass',
    'class',
    'style',
    'key',
    'ref',
    'refInFor',
    'slot',
    'scopedSlots',
    'model'
];
const prefixedRE = /^(on|nativeOn|props|domProps|hook|v)([A-Z][a-zA-Z]+)?$/;
const getRawName = (name) => {
    return name.replace(/^(on|native(On|-on)|props|dom(Props|-props)|hook|v)-?/, '');
};
/**
 * Make sure an object is an array
 * and if it is not wrap it inside one
 * @param a
 */
const makeArray = (a) => {
    return Array.isArray(a) ? a : [a];
};
/**
 * Create a function out of two other
 * @param fn1
 * @param fn2
 */
const mergeFn = (fn1, fn2) => function (...argzMain) {
    fn1 && fn1.apply(this, argzMain);
    fn2 && fn2.apply(this, argzMain);
};
/**
 * Merge two members of the spread
 * @param a
 * @param b
 */
const merge = (a, b) => {
    // initialization case
    if (a === undefined) {
        return b;
    }
    // merge of functions
    if (typeof a === 'function' && typeof b === 'function') {
        return mergeFn(a, b);
    }
    // merge of other options (like class)
    return makeArray(a).concat(b);
};
const concatenate = (src, ...otherObj) => {
    src = src || {};
    otherObj.forEach(obj => {
        Object.keys(obj).forEach((key) => {
            src[key] = merge(src[key], obj[key]);
        });
    });
    return src;
};
const groupAttr = (attrsIn) => {
    if (isVue3) {
        Object.keys(attrsIn)
            .filter(key => key.startsWith('vModel') || key.startsWith('v-model'))
            .forEach(key => {
            let valueRef = attrsIn[key];
            const rootKey = key.startsWith('vModel:')
                ? key.slice(7)
                : key.startsWith('v-model')
                    ? key.slice(8)
                    : 'modelValue';
            attrsIn[rootKey] = valueRef;
            attrsIn[`onUpdate:${rootKey}`] = ($event) => (valueRef = $event);
            delete attrsIn[key];
        });
        return attrsIn;
    }
    if (!attrsIn) {
        return undefined;
    }
    const attrsOut = {};
    Object.keys(attrsIn).forEach(name => {
        const value = attrsIn[name];
        const ccName = camelCase(name);
        if (rootAttributes.indexOf(ccName) > 0) {
            attrsOut[ccName] = value;
        }
        else if (name === 'attrs') {
            attrsOut.attrs = concatenate(attrsOut.attrs, value);
        }
        else if (prefixedRE.test(ccName)) {
            const foundName = prefixedRE.exec(ccName);
            if (foundName) {
                const prefix = foundName[1];
                const rawName = getRawName(name);
                const camelCasedName = rawName.length ? rawName[0].toLowerCase() + rawName.slice(1) : '';
                if (prefix === 'v') {
                    if (!attrsOut.directives) {
                        attrsOut.directives = [];
                    }
                    attrsOut.directives.push({
                        name: camelCasedName,
                        value
                    });
                }
                else {
                    if (!attrsOut[prefix]) {
                        attrsOut[prefix] = {};
                    }
                    if (camelCasedName.length) {
                        // if it is a literal prefixed attribute
                        attrsOut[prefix][camelCasedName] = merge(attrsOut[prefix][camelCasedName], value);
                    }
                    else {
                        // if it is a spread
                        concatenate(attrsOut[prefix], value);
                    }
                }
            }
        }
        else {
            attrsOut.attrs = attrsOut.attrs || {};
            const finalName = /^data-/.test(name) ? name : ccName === 'xlinkHref' ? 'xlink:href' : ccName;
            attrsOut.attrs[finalName] = value;
        }
    });
    return attrsOut;
};

/**
 * Determines if the given code is a VueSfc file
 * It does not throw if the code is invalid, just returns `false`
 * @param code JavaScript or vue code to analyze
 */
function isCodeVueSfc(code) {
    const parts = parseComponent(code);
    return !!parts.script || !!parts.scriptSetup || !!parts.template;
}

const EXAMPLE_FILENAME = 'example.vue';
function compileTemplateForEval(compiledComponent) {
    if (compiledComponent.template) {
        const { bindings } = compileScript({
            cssVars: [],
            script: {
                type: 'script',
                content: `export default (function () {${compiledComponent.script}})()`,
                loc: {
                    start: {
                        offset: 0
                    }
                }
            },
            source: `<script>export default (function () {${compiledComponent.script}})()</script>`,
            scriptSetup: null
        }, {
            id: '-'
        });
        const renderObject = compileTemplate({
            source: compiledComponent.template,
            filename: EXAMPLE_FILENAME,
            id: '-',
            scoped: !!compiledComponent.scopeId,
            compilerOptions: {
                bindingMetadata: bindings,
                prefixIdentifiers: true,
                mode: 'function',
                scopeId: compiledComponent.scopeId
            }
        });
        setFinalRender(compiledComponent, renderObject);
    }
}
function compileTemplateForEvalSetup(compiledComponent, code) {
    const descriptor = parseComponent(code);
    const { bindings } = compileScript(descriptor, { id: '-' });
    if (compiledComponent.template) {
        const renderObject = compileTemplate({
            source: compiledComponent.template,
            filename: EXAMPLE_FILENAME,
            id: '-',
            compilerOptions: {
                bindingMetadata: bindings,
                prefixIdentifiers: true,
                mode: 'function',
                scopeId: compiledComponent.scopeId
            }
        });
        setFinalRender(compiledComponent, renderObject);
    }
}
function setFinalRender(sfc, renderObject) {
    var _a, _b;
    sfc.script = `
${isVue3 ? 'const Vue = require("vue");const {pushScopeId: _pushScopeId, popScopeId: _popScopeId} = Vue' : ''}
const __sfc__ = (function() {${sfc.script}})()${((_a = renderObject.staticRenderFns) === null || _a === void 0 ? void 0 : _a.length)
        ? `
      __sfc__.staticRenderFns = [${(_b = renderObject.staticRenderFns) === null || _b === void 0 ? void 0 : _b.map((fn) => {
            return `function(){${fn}}`;
        }).join(',')}]`
        : ''}
  __sfc__.render = function() {${renderObject.code}}
${isVue3 ? `
${sfc.scopeId ? `_pushScopeId("${sfc.scopeId}")` : ''}
__sfc__.render = __sfc__.render()
${sfc.scopeId ? `_popScopeId()` : ''}` : ''}
return __sfc__`;
    delete sfc.template;
}

export { adaptCreateElement, compileTemplateForEval, compileTemplateForEvalSetup, concatenate, isCodeVueSfc };
