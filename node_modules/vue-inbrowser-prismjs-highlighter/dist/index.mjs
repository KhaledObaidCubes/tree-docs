import { isCodeVueSfc, parseComponent } from 'vue-inbrowser-compiler-utils';
import Prism from 'prismjs';
import 'prismjs/components/prism-clike.js';
import 'prismjs/components/prism-markup.js';
import 'prismjs/components/prism-javascript.js';
import 'prismjs/components/prism-typescript.js';
import 'prismjs/components/prism-jsx.js';
import 'prismjs/components/prism-tsx.js';
import 'prismjs/components/prism-css.js';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function getScript (code, jsxInExamples) {
    var _a;
    // In case we are loading a vue component as an example, extract script tag
    if (isCodeVueSfc(code)) {
        var parts = parseComponent(code);
        return ((_a = parts === null || parts === void 0 ? void 0 : parts.script) === null || _a === void 0 ? void 0 : _a.content) || "";
    }
    // if in JSX mode or literal return examples code as is
    if (jsxInExamples || /new Vue\(/.test(code)) {
        return code;
    }
    if (/\n\W+?export\W+default\W/.test(code) ||
        /\n\W+?module.exports(\W+)?=/.test(code)) {
        return code;
    }
    code = code || "";
    //else it will be considered pseudo jsx of vue-styleguidist
    return /^</.test(code.trim()) ? "" : code.split(/\n[\t ]*</)[0];
}

Prism.manual = true;
var prismHighlight = Prism.highlight, languages = Prism.languages;
var CONFIGURED_LANGS = ['html', 'vue-sfc', 'vsg', 'jsx', 'tsx'];
/**
 * Returns a function that returns a function will highlight the code.
 * @param errorSquigglesClassPrefix class prefix for error squiggles
 * @returns function that will return the code highlighter for the given language
 */
function index (errorSquigglesClassPrefix) {
    return __awaiter(this, void 0, void 0, function () {
        /**
         * Return a function that will highlight the code.
         * @param lang language of the code
         * @param jsxInExamples whether to use jsx or tsx for highlighting
         */
        function getHighlighter(lang, jsxInExamples) {
            if (jsxInExamples === void 0) { jsxInExamples = false; }
            if (lang === 'vsg') {
                // render vsg format
                return function (code) {
                    if (!code) {
                        return '';
                    }
                    var scriptCode = getScript(code, jsxInExamples);
                    var scriptCodeHighlighted = prismHighlight(scriptCode, languages[jsxInExamples ? 'tsx' : 'ts'], lang);
                    if (code.length === scriptCode.length) {
                        return scriptCodeHighlighted;
                    }
                    var templateCode = code.slice(scriptCode.length);
                    var templateHighlighted = prismHighlight(templateCode, languages['html'], lang);
                    return (renderLines(scriptCodeHighlighted + templateHighlighted));
                };
            }
            else if (['html', 'vue-sfc'].includes(lang)) {
                // render vue SFC component format
                var langScheme_1 = languages.html;
                return function (code) {
                    var comp = parseComponent(code);
                    var newCode = comp.script
                        ? getCodeWithoutScript(code, comp.script, comp.scriptSetup)
                        : code;
                    var htmlHighlighted = prismHighlight(newCode, langScheme_1, 'html');
                    var highlightedScript = comp.script
                        ? htmlHighlighted.replace(getReplacedTokenRE(comp.script), prismHighlight(comp.script.content, languages[comp.script.lang || 'ts'], comp.script.lang || 'ts'))
                        : htmlHighlighted;
                    var highlightedScriptSetup = comp.scriptSetup
                        ? highlightedScript.replace(getReplacedTokenRE(comp.scriptSetup), prismHighlight(comp.scriptSetup.content, languages.ts, 'ts'))
                        : highlightedScript;
                    return renderLines(highlightedScriptSetup);
                };
            }
            else {
                // all other formats
                var langScheme_2 = languages[lang];
                return function (code, errorLoc) {
                    return renderLines(prismHighlight(code, langScheme_2, lang));
                };
            }
        }
        function addSquigglesManagement(highlight) {
            return function (code, errorLoc) { return getSquiggles(errorLoc, errorSquigglesClassPrefix) + highlight(code); };
        }
        return __generator(this, function (_a) {
            return [2 /*return*/, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return addSquigglesManagement(getHighlighter.apply(void 0, __spreadArray([], __read(args), false)));
                }];
        });
    });
}
function renderLines(code) {
    return "<span class=\"line\">".concat(code.replace(/\n/g, "</span>\n<span class='line'>"), "</span>");
}
function getSquiggles(errorLoc, errorSquigglesClassPrefix) {
    if (!errorLoc)
        return '';
    var errorWidth = 'end' in errorLoc ? errorLoc.end.column - errorLoc.start.column + 1 : 2;
    var _a = 'start' in errorLoc ? errorLoc.start : errorLoc, line = _a.line, column = _a.column;
    return ("<span class=\"".concat(errorSquigglesClassPrefix, "-wrapper\">") +
        (line > 0 ? Array(line - 1).join('\n') : '') +
        Array(column).join(' ') +
        "<span class=\"".concat(errorSquigglesClassPrefix, "\">") +
        Array(errorWidth).join(' ') +
        '</span></span>');
}
/**
 * Return SFC code without any script part.
 * Why? Because we want to highlight the script part in a separate manner.
 * This will allow us to highlight typescript code.
 * @param code SFC code
 * @param script script part of the parsed SFC
 * @param scriptSetup script part of the parsed SFC
 * @returns vue SCF code without any script part.
 * @example
 *    const code = `
 *    <template>
 *    <div>hello</div>
 *    </template>
 *    <script setup lang="ts">
 *    console.log('hello')
 *    </script>
 *    <script lang="ts">
 *    function hello() {
 *    }
 *    </script>`
 *
 *  => Returns
 *
 *     `<template>
 *     <div>hello</div>
 *     </template>
 *     <script setup lang="ts">setup</script>
 *     <script lang="ts"> </script>
 */
function getCodeWithoutScript(code, script, scriptSetup) {
    // in vue 3 the structure of the script SCF object is different
    // the start & stop are in a `loc` object.
    if (script.loc) {
        var orderedScripts = scriptSetup
            ? [scriptSetup, script].sort(function (s1, s2) { return (s1.loc.start.offset > s2.loc.start.offset ? 1 : -1); })
            : [script];
        var firstScript = orderedScripts[0];
        var nextScript = orderedScripts[1];
        if (nextScript) {
            return (code.slice(0, firstScript.loc.start.offset) +
                getSpacer(firstScript) +
                code.slice(firstScript.loc.end.offset, nextScript.loc.start.offset) +
                getSpacer(nextScript) +
                code.slice(nextScript.loc.end.offset));
        }
        else {
            return (code.slice(0, firstScript.loc.start.offset) +
                getSpacer(firstScript) +
                code.slice(firstScript.loc.end.offset));
        }
    }
    // in vue 2 the start & stop are directly attached to the script member.
    return code.slice(0, script.start) + ' ' + code.slice(script.end);
}
function getSpacer(s) {
    return s.setup ? 'setup' : ' ';
}
function getReplacedTokenRE(s) {
    return new RegExp("<span class=\"token script\"><span class=\"token language-javascript\">".concat(getSpacer(s), "</span></span>"));
}

export { CONFIGURED_LANGS, index as default };
//# sourceMappingURL=index.mjs.map
