var M = Object.defineProperty;
var G = (e, t, r) => t in e ? M(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var y = (e, t, r) => (G(e, typeof t != "symbol" ? t + "" : t, r), r);
import * as K from "vue";
import { defineComponent as f, markRaw as P, h as $, openBlock as m, createElementBlock as E, Fragment as Y, toDisplayString as k, createCommentVNode as N, createBlock as L, resolveDynamicComponent as F, createSlots as z, renderList as H, withCtx as C, renderSlot as S, normalizeProps as J, guardReactiveProps as X, resolveComponent as _, mergeProps as I, createElementVNode as A, createVNode as Q } from "vue";
import W from "hash-sum";
import { compile as Z, isCodeVueSfc as ee, adaptCreateElement as te, concatenate as re, compileTemplateForEval as oe, addScopedStyle as se } from "vue-inbrowser-compiler-sucrase";
import { parse as ie } from "@vue/compiler-dom";
import { createCompilerError as ne } from "@vue/compiler-core";
import { parse as T } from "acorn";
import { simple as ae, ancestor as ce } from "acorn-walk";
import { PrismEditor as le } from "vue-prism-editor";
import de, { CONFIGURED_LANGS as ue } from "vue-inbrowser-prismjs-highlighter";
import pe from "debounce";
const me = 1, he = 4, fe = 5;
function D(e, t) {
  if (!e.template)
    return;
  let r;
  try {
    r = ie(e.template);
  } catch (c) {
    throw ne(c.code, c.loc);
  }
  if (!t)
    return;
  const n = e.props ? Array.isArray(e.props) ? e.props : Object.keys(e.props) : [], o = e.data ? typeof e.data == "function" ? Object.keys(e.data()) : Object.keys(e.data) : [], a = e.computed ? Object.keys(e.computed) : [], s = e && e.methods ? Object.keys(e.methods) : [], i = e && typeof e.setup == "function" ? Object.keys(e.setup() ?? {}) : [], l = [
    ...n,
    ...o,
    ...a,
    ...s,
    ...i
  ];
  x(r, [
    (c, q) => {
      const u = [];
      if (c.type === me)
        c.props.forEach(
          (d) => {
            const v = d.type !== he && d.exp ? d.exp.content : void 0;
            if (v)
              if (d.name === "slot") {
                const p = T(`var ${v}=1`, { ecmaVersion: 2020 });
                ae(p, {
                  VariableDeclarator(b) {
                    const { id: h } = b;
                    switch (h.type) {
                      case "ArrayPattern":
                        h.elements.forEach((g) => {
                          u.push(g.name);
                        });
                        break;
                      case "ObjectPattern":
                        h.properties.forEach((g) => {
                          u.push(g.value.name);
                        });
                        break;
                      case "Identifier":
                        u.push(h.name);
                        break;
                    }
                    return !1;
                  }
                });
              } else if (d.name === "for") {
                const [p] = v.split(/( in | of )/), b = /\((\w+),(\w+)\)/;
                if (b.test(p.replace(" ", ""))) {
                  const [, h, g] = Array.from(
                    b.exec(p.replace(" ", "")) || []
                  );
                  u.push(h || ""), u.push(g || "");
                } else
                  u.push(p);
              } else
                try {
                  B(v, l, [
                    ...q,
                    ...u
                  ]);
                } catch (p) {
                  throw new j(
                    p.message,
                    v,
                    p,
                    d.loc
                  );
                }
          }
        );
      else if (c.type === fe)
        try {
          c.content && B(
            c.content.content,
            l,
            q
          );
        } catch (d) {
          throw new j(
            d.message,
            c.content,
            d,
            c.loc
          );
        }
      return u;
    }
  ]);
}
function B(e, t, r) {
  const n = T(`(function(){return ${e}})()`, {
    ecmaVersion: 2020
  });
  ce(n, {
    Identifier(o, a) {
      const s = o.name;
      if (
        // if the identifier is a function call leave it alone
        !(a.length >= 2 && a[a.length - 2].type === "CallExpression" && a[a.length - 2].callee.name === s) && t.indexOf(s) === -1 && r.indexOf(s) === -1 && !/^\$/.test(s)
      ) {
        if (a.filter(
          (l) => l.type === "ArrowFunctionExpression" || l.type === "FunctionExpression"
        ).some(
          (l) => l.params.some((c) => c.name === s)
        ))
          return;
        throw new ve(
          `Variable "${s}" is not defined.`,
          s
        );
      }
    }
  });
}
function x(e, t, r = []) {
  const n = (a, s) => {
    const { children: i } = a;
    if (i)
      for (const l of i)
        x(l, t, s);
  }, o = t.reduce((a, s) => {
    const i = s(e, r);
    return i && i.length ? a.concat(i) : a;
  }, []);
  n(e, [
    ...r,
    ...o
  ]);
}
class ve extends Error {
  constructor(r, n) {
    super(r);
    y(this, "varName");
    this.varName = n;
  }
}
class j extends Error {
  constructor(r, n, o, a) {
    super(r);
    y(this, "expression");
    y(this, "subError");
    y(this, "loc");
    this.expression = n, this.subError = o, this.loc = a;
  }
}
function ge(e, t, r, n, o) {
  return new Function(
    "require",
    "__pragma__",
    "__concatenate__",
    "h",
    e
  )(t, r, n, o);
}
function ye(e, t) {
  if (e = e || {}, !(t in e))
    throw new Error(
      "import or require() statements can be added only by setting it using the requires prop"
    );
  return e[t];
}
const be = f({
  name: "VueLivePreviewComponent",
  emits: ["error", "success", "detect-language"],
  components: {},
  errorCaptured(e) {
    this.handleError(e);
  },
  props: {
    debug: {
      type: Boolean,
      default: !1
    },
    /**
     * code rendered
     */
    code: {
      type: String,
      required: !0
    },
    /**
     * Hashtable of auto-registered components
     * @example { DatePicker: VueDatePicker }
     * @example { VueDatePicker }
     */
    components: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Hashtable of auto-registered directives
     * @example { Tooltip: VueTooltip }
     * @example { VueTooltip }
     */
    directives: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Hashtable of modules available in require and import statements
     * in the code prop
     * @example { lodash: require("lodash") }
     * @example { moment: require("moment") }
     */
    requires: {
      type: Object,
      default: () => {
      }
    },
    jsx: {
      type: Boolean,
      default: !1
    },
    /**
     * Outside data to the preview
     * @example { count: 1 }
     */
    dataScope: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Avoid checking variables for availability it template
     */
    checkVariableAvailability: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      scope: this.generateScope(),
      previewedComponent: P(f({
        render: () => $("div")
      })),
      iteration: 0,
      error: !1,
      removeScopedStyle: () => {
      },
      compiledCodeForDebug: ""
    };
  },
  computed: {
    requiresPlusVue() {
      return { vue: K, ...this.requires };
    }
  },
  created() {
    this.renderComponent(this.code.trim());
  },
  destroyed() {
    this.removeStyle();
  },
  watch: {
    code(e) {
      this.renderComponent(e.trim());
    }
  },
  methods: {
    /**
     * Generates the Scope Id attribute value. It will be added to each
     * tag if a style is applied to scope the style only to this example
     */
    generateScope() {
      return "v-xxxxxxxx".replace(/[xy]/g, (e) => {
        const t = Math.random() * 16 | 0;
        return (e === "x" ? t : t & 3 | 8).toString(16);
      });
    },
    handleError(e) {
      e.constructor === j && (e.message = `Cannot parse template expression: ${JSON.stringify(
        e.expression.content || e.expression
      )}

${e.message}`), this.$emit("error", e), this.error = e.message;
    },
    removeStyle() {
      this.removeScopedStyle && this.removeScopedStyle();
    },
    async renderComponent(e) {
      let t = f({}), r;
      const n = `data-${this.scope}`;
      try {
        const o = Z(
          e,
          this.jsx ? {
            jsxPragma: "__pragma__(h)"
          } : {},
          n
        );
        if (this.debug && (this.compiledCodeForDebug = Object.entries(o).map(([s, i]) => typeof i == "string" ? `<${s}>
${i}
</${s}>` : "").join(`

`)), r = o.style, o.script) {
          this.$emit("detect-language", ee(e) ? "vue" : "vsg");
          const s = async () => {
            const i = o.script, l = {};
            await Promise.allSettled(Object.keys(this.requiresPlusVue).map(async (c) => {
              l[c] = this.requiresPlusVue[c] instanceof Promise ? (await this.requiresPlusVue[c]).default : this.requiresPlusVue[c];
            })), t = f(ge(
              i,
              (c) => ye(l, c),
              te,
              re,
              $
            ) || {}), t.name = "VueLiveCompiledExample";
          };
          if (await s(), typeof t.template == "string" && (o.template = t.template, oe(o), await s(), D(
            {
              ...t,
              template: t.template
            },
            this.checkVariableAvailability
          ), delete t.template), this.dataScope) {
            const i = { ...t == null ? void 0 : t.data(), ...this.dataScope };
            t.data = () => i;
          }
        }
        const a = o.raw.template;
        a && D(
          {
            ...t,
            template: a
          },
          this.checkVariableAvailability
        );
      } catch (o) {
        this.handleError(o);
        return;
      }
      if (this.components && (t.components ? t.components = { ...t.components, ...this.components } : t.components = this.components), this.directives && (t.directives ? t.directives = { ...t.directives, ...this.directives } : t.directives = this.directives), this.removeStyle(), r && (t.__scopeId = n, this.removeScopedStyle = se(r, this.scope)), !t.render) {
        this.handleError({
          message: "[Vue Live] no template or render function specified. Example cannot be rendered."
        });
        return;
      }
      t.errorCaptured = (o) => (this.handleError(o), !1), this.previewedComponent = P(t), this.iteration = this.iteration + 1, this.error = !1, this.$emit("success");
    }
  }
});
const V = (e, t) => {
  const r = e.__vccOpts || e;
  for (const [n, o] of t)
    r[n] = o;
  return r;
}, Ee = { key: 0 }, Le = {
  key: 1,
  class: "VueLive-error"
};
function we(e, t, r, n, o, a) {
  return m(), E(Y, null, [
    e.debug ? (m(), E("pre", Ee, k(e.compiledCodeForDebug), 1)) : N("", !0),
    e.error ? (m(), E("pre", Le, k(e.error), 1)) : e.previewedComponent ? (m(), L(F(e.previewedComponent), { key: e.iteration }, z({ _: 2 }, [
      H(e.$slots, (s, i) => ({
        name: i,
        fn: C((l) => [
          S(e.$slots, i, J(X(l)))
        ])
      }))
    ]), 1024)) : N("", !0)
  ], 64);
}
const R = /* @__PURE__ */ V(be, [["render", we]]);
const Ve = 300, Pe = f({
  name: "VueLiveEditor",
  inheritAttrs: !1,
  components: { PrismEditor: le },
  props: {
    code: {
      type: String,
      required: !0
    },
    error: {
      type: [Error, Object],
      default: void 0
    },
    delay: {
      type: Number,
      default: Ve
    },
    editorProps: {
      type: Object,
      default: () => ({})
    },
    prismLang: {
      type: String,
      default: "html",
      validator: (e) => ue.includes(e)
    },
    jsx: {
      type: Boolean,
      default: !1
    },
    squiggles: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      updatePreview: () => {
      },
      /**
       * This data only gets changed when changing language.
       * it allows for copy and pasting without having the code
       * editor repainted every keystroke
       */
      stableCode: this.code,
      highlight: () => (e) => e
    };
  },
  async beforeMount() {
    this.highlight = await de("VueLive-squiggles");
  },
  methods: {
    highlighter(e) {
      return this.highlight(this.prismLang, this.jsx)(
        e,
        this.squiggles && this.adaptedErrorLoc ? this.adaptedErrorLoc : void 0
      );
    }
  },
  computed: {
    adaptedErrorLoc() {
      var n;
      if (this.prismLang !== "vsg")
        return;
      const e = /\n[\t ]*</.exec(this.stableCode), t = e ? this.stableCode.slice(0, e.index + 1) : "", r = (/^[\t ]*</.test(t) ? 0 : ((n = t.match(/\n/g)) == null ? void 0 : n.length) || 0) + 1;
      return this.error && this.error.loc ? this.error.loc.start ? {
        start: {
          ...this.error.loc.start,
          line: this.error.loc.start.line + r
        },
        end: {
          ...this.error.loc.end,
          line: this.error.loc.end.line + r
        }
      } : this.error.loc.line ? {
        start: {
          ...this.error.loc,
          line: this.error.loc.line + r
        },
        end: {
          ...this.error.loc,
          line: this.error.loc.line + r
        }
      } : void 0 : void 0;
    }
  },
  watch: {
    code(e) {
      this.updatePreview(e);
    }
  },
  created() {
    this.updatePreview = pe((e) => {
      this.stableCode = e, this.$emit("change", e);
    }, this.delay);
  }
});
function Ce(e, t, r, n, o, a) {
  const s = _("PrismEditor");
  return m(), L(s, I({
    class: { "VueLive-LineNumbers": e.editorProps.lineNumbers },
    modelValue: e.stableCode,
    "onUpdate:modelValue": [
      t[0] || (t[0] = (i) => e.stableCode = i),
      e.updatePreview
    ],
    highlight: e.highlighter
  }, e.editorProps, { lineNumbers: !1 }), null, 16, ["class", "modelValue", "onUpdate:modelValue", "highlight"]);
}
const U = /* @__PURE__ */ V(Pe, [["render", Ce]]);
const Se = {}, _e = { class: "VueLive-container" }, je = { class: "VueLive-editor" }, Oe = { class: "VueLivePreview" };
function qe(e, t) {
  return m(), E("div", _e, [
    A("div", je, [
      S(e.$slots, "editor")
    ]),
    A("div", Oe, [
      S(e.$slots, "preview")
    ])
  ]);
}
const $e = /* @__PURE__ */ V(Se, [["render", qe]]), ke = {
  vue: "html",
  vsg: "vsg"
}, Ne = 300, Ae = f({
  name: "VueLive",
  components: { Preview: R, Editor: U },
  props: {
    /**
     * code rendered in the preview and the editor
     */
    code: {
      type: String,
      required: !0
    },
    /**
     * Layout vue component with 2 slots named `editor` & `preview`
     */
    layout: {
      type: Object,
      default: void 0
    },
    /**
     * Hashtable of auto-registered components
     * @example { DatePicker: VueDatePicker }
     * @example { VueDatePicker }
     */
    components: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Hashtable of auto-registered directives
     * @example { Tooltip: VueTooltip }
     * @example { VueTooltip }
     */
    directives: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Hashtable of modules available in require and import statements
     * in the Preview component
     * @example { lodash: require("lodash") }
     * @example { "foo/bar.js": import("foo/bar.js") }
     */
    requires: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Time in ms debouncing updates to the preview
     */
    delay: {
      type: Number,
      default: Ne
    },
    /**
     * Do the code contain JSX rendered functions
     */
    jsx: {
      type: Boolean,
      default: !1
    },
    /**
     * These props will be passed as a spreat to your layout
     * They can be used to change the style
     */
    layoutProps: {
      type: Object,
      default: void 0
    },
    /**
     * Props of vue-prism-editor
     * @example { lineNumbers: true }
     * @see https://github.com/koca/vue-prism-editor
     */
    editorProps: {
      type: Object,
      default: () => ({})
    },
    /**
     * Outside data to the preview
     * @example { count: 1 }
     */
    dataScope: {
      type: Object,
      default: () => {
      }
    },
    /**
     * Set if checking variables for availability
     * when used in template
     * NOTE: if this is not checked, undefined vars will yield a blank output
     */
    checkVariableAvailability: {
      type: Boolean,
      default: !0
    },
    /**
     * Show the red markings
     * where the compiler found errors
     */
    squiggles: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      model: this.code,
      lang: "vue",
      prismLang: "html",
      VueLiveDefaultLayout: P($e),
      /**
       * this data only gets changed when changing language.
       * it allows for copy and pasting without having the code
       * editor repainted every keystroke
       */
      stableCode: this.code,
      error: void 0
    };
  },
  computed: {
    codeKey() {
      return W(this.model);
    }
  },
  watch: {
    code(e) {
      this.stableCode = e, this.model = e;
    }
  },
  methods: {
    updatePreview(e) {
      this.stableCode = e, this.model = e, this.$emit("change", e);
    },
    switchLanguage(e) {
      this.lang = e;
      const t = ke[e];
      this.prismLang !== t && (this.prismLang = t, this.stableCode = this.model);
    },
    handleSuccess() {
      this.error = void 0, this.$emit("success");
    },
    handleError(e) {
      this.error = e, this.$emit("error", e);
    }
  }
});
function De(e, t, r, n, o, a) {
  const s = _("Editor"), i = _("Preview");
  return m(), L(F(e.layout ? e.layout : e.VueLiveDefaultLayout), I(e.layoutProps, {
    code: e.stableCode,
    language: e.lang,
    "prism-lang": e.prismLang,
    requires: e.requires,
    "data-scope": e.dataScope,
    components: e.components
  }), {
    editor: C(() => [
      Q(s, {
        code: e.stableCode,
        delay: e.delay,
        "prism-lang": e.prismLang,
        "editor-props": e.editorProps,
        error: e.error,
        jsx: e.jsx,
        squiggles: e.squiggles,
        onChange: e.updatePreview
      }, null, 8, ["code", "delay", "prism-lang", "editor-props", "error", "jsx", "squiggles", "onChange"])
    ]),
    preview: C(() => [
      (m(), L(i, {
        key: e.codeKey,
        code: e.model,
        onDetectLanguage: e.switchLanguage,
        onError: e.handleError,
        onSuccess: e.handleSuccess,
        components: e.components,
        directives: e.directives,
        requires: e.requires,
        jsx: e.jsx,
        "data-scope": e.dataScope,
        "check-variable-availability": e.checkVariableAvailability
      }, null, 8, ["code", "onDetectLanguage", "onError", "onSuccess", "components", "directives", "requires", "jsx", "data-scope", "check-variable-availability"]))
    ]),
    _: 1
  }, 16, ["code", "language", "prism-lang", "requires", "data-scope", "components"]);
}
const Be = /* @__PURE__ */ V(Ae, [["render", De]]);
function O(e) {
  O.installed || (O.installed = !0, e.component("VueLive", Be), e.component("VueLivePreview", R), e.component("VueLiveEditor", U));
}
const Fe = {
  install: O
};
let w = null;
typeof window < "u" ? w = window.Vue : typeof global < "u" && (w = global.Vue);
w && w.use(Fe);
export {
  Be as VueLive,
  U as VueLiveEditor,
  R as VueLivePreview,
  Fe as default,
  O as install
};
