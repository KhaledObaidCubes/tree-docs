import { parseComponent, isVue3, compileTemplateForEvalSetup, compileTemplateForEval, isCodeVueSfc } from 'vue-inbrowser-compiler-utils';
export { adaptCreateElement, addScopedStyle, compileTemplateForEval, concatenate, isCodeVueSfc, parseComponent } from 'vue-inbrowser-compiler-utils';
import { transform } from 'sucrase';
import walkes from 'walkes';
import { parse as parse$1 } from '@babel/parser';

const babelParserOptions = {
    sourceType: 'module',
    strictMode: false,
    tokens: true,
    plugins: [
        'jsx',
        'decorators-legacy',
        'doExpressions',
        'objectRestSpread',
        'classProperties',
        'classPrivateProperties',
        'classPrivateMethods',
        'exportDefaultFrom',
        'exportNamespaceFrom',
        'asyncGenerators',
        'functionBind',
        'functionSent',
        'dynamicImport',
        'numericSeparator',
        'optionalChaining',
        'importMeta',
        'bigInt',
        'optionalCatchBinding',
        'throwExpressions',
        'nullishCoalescingOperator',
        'typescript'
    ]
};
function buildParse(options = {}) {
    options = Object.assign(Object.assign({}, babelParserOptions), options);
    return {
        parse(src) {
            return parse$1(src, options);
        }
    };
}

let parse;
function getAst(code) {
    parse = parse !== null && parse !== void 0 ? parse : buildParse().parse;
    return parse(code);
}

function transformOneJSXSpread(node, code, offset, config) {
    const start = node.start + offset;
    const end = node.end + offset;
    const objectAssign = config.objectAssign || 'Object.assign';
    const statement = code.substring(start, end);
    const transpiledStatement = `<${node.name.name} {...${objectAssign}(${node.attributes
        .map((attrNode) => {
        if (attrNode.type === 'JSXSpreadAttribute') {
            return `${code.substring(attrNode.argument.start + offset, attrNode.argument.end + offset)}`;
        }
        else {
            return `{${attrNode.name.name}:${attrNode.value.type.endsWith('Literal')
                ? JSON.stringify(attrNode.value.value)
                : code.substring(attrNode.value.expression.start + offset, attrNode.value.expression.end + offset)}}`;
        }
    })
        .join(',')})} ${node.selfClosing ? '/' : ''}>`;
    code = code.substring(0, start) + transpiledStatement + code.substring(end);
    offset = transpiledStatement.length - statement.length;
    return { code, offset };
}

const buildStyles = function (styles) {
    let _styles = '';
    if (styles) {
        styles.forEach(it => {
            if (it) {
                _styles += it;
            }
        });
    }
    if (_styles !== '') {
        return _styles.trim();
    }
    return undefined;
};
function parseScriptCode(code, config = {}) {
    let preprocessing = '';
    let startIndex = -1;
    let endIndex = -1;
    let offset = 0;
    let renderFunctionStart = -1;
    const ast = getAst(code).program;
    let isFunctional = false;
    const setFunctionalComponent = (node) => {
        if (['ArrowFunctionExpression', 'FunctionDeclaration'].includes(node.type)) {
            isFunctional = true;
        }
    };
    walkes(ast, {
        // export const MyComponent = {}
        ExportNamedDeclaration(node) {
            preprocessing = code.slice(0, node.start + offset);
            startIndex = node.declaration.declarations[0].init.start + offset;
            endIndex = node.declaration.declarations[0].init.end + offset;
            if (node.declarations) {
                renderFunctionStart = getRenderFunctionStart(node.declarations[0]);
            }
            setFunctionalComponent(node.declaration.declarations[0]);
        },
        //export default {}
        ExportDefaultDeclaration(node) {
            preprocessing = code.slice(0, node.start + offset);
            startIndex = node.declaration.start + offset;
            endIndex = node.declaration.end + offset;
            renderFunctionStart = getRenderFunctionStart(node.declaration);
            setFunctionalComponent(node.declaration);
        },
        //module.exports = {}
        AssignmentExpression(node) {
            if (/exports/.test(node.left.name) ||
                (node.left.object &&
                    /module/.test(node.left.object.name) &&
                    /exports/.test(node.left.property.name))) {
                preprocessing = code.slice(0, node.start + offset);
                startIndex = node.right.start + offset;
                endIndex = node.right.end + offset;
                setFunctionalComponent(node.right);
            }
        }
    });
    walkes(ast, {
        JSXOpeningElement(node) {
            if (node.attributes.some((attrNode) => attrNode.type === 'JSXSpreadAttribute')) {
                const ret = transformOneJSXSpread(node, code, offset, config);
                if (node.start + offset < startIndex) {
                    offset += ret.offset;
                }
                else if (node.end + offset < endIndex) {
                    endIndex += ret.offset;
                }
                code = ret.code;
            }
        }
    });
    if (startIndex === -1) {
        throw new Error('Failed to parse single file component: ' + code);
    }
    if (renderFunctionStart > 0 && !isVue3) {
        renderFunctionStart += offset;
        code = insertCreateElementFunction(code.slice(0, renderFunctionStart + 1), code.slice(renderFunctionStart + 1));
        endIndex += JSX_ADDON_LENGTH;
    }
    const component = isFunctional
        ? `render: ${code.slice(startIndex, endIndex)}`
        : code.slice(startIndex + 1, endIndex - 1);
    return {
        preprocessing,
        component,
        postprocessing: code.slice(endIndex)
    };
}
const JSX_ADDON_LENGTH = 31;
function getRenderFunctionStart(objectExpression) {
    if (objectExpression && objectExpression.properties) {
        const nodeProperties = objectExpression.properties;
        const renderFunctionObj = nodeProperties.find((p) => p.key && p.key.type === 'Identifier' && p.key.name === 'render');
        if (renderFunctionObj === null || renderFunctionObj === void 0 ? void 0 : renderFunctionObj.body) {
            return renderFunctionObj.body.start;
        }
    }
    return -1;
}
function insertCreateElementFunction(before, after) {
    return `${before};const h = this.$createElement;${after}`;
}
function parseScriptSetupCode(code) {
    const varNames = [];
    walkes(getAst(code), {
        ImportDeclaration(node) {
            if (node.specifiers.length === 0) {
                // import 'foo'
                return;
            }
            if (node.specifiers[0].type === 'ImportDefaultSpecifier') {
                // import foo from 'foo'
                varNames.push(node.specifiers[0].local.name);
            }
            else if (node.specifiers[0].type === 'ImportSpecifier') {
                // import { foo } from 'foo'
                node.specifiers.forEach((specifier) => {
                    varNames.push(specifier.local.name);
                });
            }
        },
        VariableDeclaration(node) {
            node.declarations.forEach((declaration) => {
                if (declaration.id.name) {
                    // simple variable declaration
                    varNames.push(declaration.id.name);
                }
                else if (declaration.id.properties) {
                    // spread variable declaration
                    // const { all:names } = {all: 'foo'}
                    declaration.id.properties.forEach((p) => {
                        varNames.push(p.value.name);
                    });
                }
            });
        },
        FunctionDeclaration(node) {
            varNames.push(node.id.name);
        }
    });
    return `setup(){
${code}
return {${varNames.join(',')}}
function defineProps(props){ return props;}
function defineEmits(){ return function emit() {}}
function defineExpose(){}
}`;
}
/**
 * Coming out of this function all SFC should be in the `new Vue()` format
 * it should as well have been stripped of exports and all imports should have been
 * transformed into requires
 */
function normalizeSfcComponent(code, config = {}) {
    const { script, scriptSetup, template, styles } = parseComponent(code);
    const { preprocessing = '', component = '', } = scriptSetup
        ? {
            preprocessing: script === null || script === void 0 ? void 0 : script.content,
            component: parseScriptSetupCode(scriptSetup.content)
        }
        : script
            ? parseScriptCode(script.content)
            : {};
    return {
        template: template === null || template === void 0 ? void 0 : template.content,
        script: [preprocessing, `return {${component}}`].join(';'),
        style: buildStyles(styles.map(styleBlock => styleBlock.content)),
        setup: Boolean(scriptSetup === null || scriptSetup === void 0 ? void 0 : scriptSetup.content)
    };
}

/**
 * Reads the code in string and separates the javascript part and the html part
 * then sets the nameVarComponent variable with the value of the component parameters
 * @param code
 * @param config sucrase config to be used when transforming
 *
 */
function compileVueCodeForEvalFunction(code, config = {}, scopeId) {
    const nonCompiledComponent = prepareVueCodeForEvalFunction(code, config);
    const configWithTransforms = {
        production: true,
        jsxPragma: config.jsxPragma,
        jsxFragmentPragma: config.jsxFragmentPragma,
        transforms: ['typescript', 'imports', ...(config.jsxPragma ? ['jsx'] : [])]
    };
    const compiledComponent = Object.assign(Object.assign({}, nonCompiledComponent), { scopeId, script: transform(nonCompiledComponent.script, configWithTransforms).code });
    if (nonCompiledComponent.setup && isVue3) {
        compileTemplateForEvalSetup(compiledComponent, code);
    }
    else {
        compileTemplateForEval(compiledComponent);
    }
    return Object.assign(Object.assign({}, compiledComponent), { raw: nonCompiledComponent });
}
function prepareVueCodeForEvalFunction(code, config) {
    let style;
    let vsgMode = false;
    let template;
    // if the component is written as a Vue sfc,
    // transform it in to a "return"
    // even if jsx is used in an sfc we still use this use case
    if (isCodeVueSfc(code)) {
        return normalizeSfcComponent(code, config);
    }
    // if it's not a new Vue, it must be a simple template or a vsg format
    // lets separate the template from the script
    if (!/new Vue\(/.test(code)) {
        // this for jsx examples without the SFC shell
        // export default {render: (h) => <Button>}
        if (config.jsxPragma) {
            const { preprocessing, component } = parseScriptCode(code, config);
            return {
                script: `${preprocessing};return {${component}};`,
                setup: false
            };
        }
        const findStartTemplateMatch = /^[\t ]*</.test(code) ? { index: -1 } : code.match(/\n[\t ]*</);
        const limitScript = findStartTemplateMatch && findStartTemplateMatch.index !== undefined
            ? findStartTemplateMatch.index + 1 // we don't want to count the \n in there
            : -1;
        template = limitScript > -1 ? code.slice(limitScript) : undefined;
        code = limitScript > -1 ? code.slice(0, limitScript) : code;
        vsgMode = true;
    }
    const ast = getAst(code);
    let offset = 0;
    const varNames = [];
    walkes(ast.program, Object.assign({ 
        // replace `new Vue({data})` by `return {data}`
        ExpressionStatement(node) {
            if (node.expression.type === 'NewExpression' && node.expression.callee.name === 'Vue') {
                const before = code.slice(0, node.expression.start + offset);
                const optionsNode = node.expression.arguments && node.expression.arguments.length
                    ? node.expression.arguments[0]
                    : undefined;
                const renderIndex = getRenderFunctionStart(optionsNode);
                let endIndex = optionsNode.end;
                if (renderIndex > 0 && !isVue3) {
                    code = insertCreateElementFunction(code.slice(0, renderIndex + 1), code.slice(renderIndex + 1));
                    endIndex += JSX_ADDON_LENGTH;
                }
                const after = optionsNode ? code.slice(optionsNode.start + offset, endIndex + offset) : '';
                code = before + ';return ' + after;
            }
        },
        // transform all imports into require function calls
        ImportDeclaration(node) {
            if (vsgMode && node.specifiers) {
                node.specifiers.forEach((s) => varNames.push(s.local.name));
            }
        } }, (vsgMode
        ? {
            VariableDeclaration(node) {
                node.declarations.forEach((declaration) => {
                    if (declaration.id.name) {
                        // simple variable declaration
                        varNames.push(declaration.id.name);
                    }
                    else if (declaration.id.properties) {
                        // spread variable declaration
                        // const { all:names } = {all: 'foo'}
                        declaration.id.properties.forEach((p) => {
                            varNames.push(p.value.name);
                        });
                    }
                });
            },
            FunctionDeclaration(node) {
                varNames.push(node.id.name);
            }
        }
        : {})));
    if (vsgMode) {
        code += `;return {data:function(){return {${
        // add local vars in data
        // this is done through an object like {varName: varName}
        // since each varName is defined in compiledCode, it can be used to init
        // the data object here
        varNames.map(varName => `${varName}:${varName}`).join(',')}};}}`;
    }
    return {
        script: code,
        style,
        template: isVue3 || !template ? template : `<div>${template}</div>`,
        setup: false
    };
}

function getImports(code) {
    const imports = [];
    try {
        const ast = getAst(code);
        walkes(ast.program, {
            ImportDeclaration(node) {
                imports.push(node.source.value);
            },
            CallExpression(node) {
                if (node.callee.name === 'require' && node.arguments[0].value) {
                    imports.push(node.arguments[0].value);
                }
            }
        });
        return isVue3 ? ['vue', ...imports] : imports;
    }
    catch (e) {
        return isVue3 ? ['vue'] : [];
    }
}

export { compileVueCodeForEvalFunction as compile, getImports };
